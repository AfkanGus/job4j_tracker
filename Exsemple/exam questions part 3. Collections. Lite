Вопросы.

1. Что такое "коллекция".
Коллекции - это классы, позволяющие работать с наборами однотипных данных.
В Java основная структура для работы с наборами данных - это массив.
Все классы коллекций внутри используют либо массив, либо связанные списки.
Всего есть 4 базовых операции.
ArrayList names = new ArrayList();
  - вставка данных;names.add("&&");
  - замена данных;names.set(0,"&&);
  - удаление данных;names.remove(0);
  - чтение данных.
  for (int index = 0; index < names.size(); index++) {
      Object value = names.get(index);
      System.out.println(value);
  }
  Чтение данных в ArrayList происходит аналогично массиву.
  В ArrayList есть метод size, который возвращает размер коллекции.
  Метод get позволяет получить элемент по индексу.

1.1. Перечислите основные методы из интерфейса java.util.Collection.
Основные:

int size() - метод который возвращает размер коллекции
boolean isEmpty()
boolean contains(Object o)
Iterator<E> iterator()
Object[] toArray()
boolean add(E e)
boolean remove(Object o)
void clear()

Остальные:
boolean containsAll(Collection<?> c)
boolean addAll(Collection<? extends E> c)
boolean removeAll(Collection<?> c)
boolean retainAll(Collection<?> c)
boolean equals(Object o)
int hashCode()

2. Назовите преимущества использования коллекций.
отсутствует необходимость следить за размерами коллекции (в отличае от массива);

позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано много методов по добавлению, удалению, сортировке элементов и т.п.;

если правильно подобрать коллекцию, то можно увеличить производительность программы;

упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

3. Какие данные могут хранить коллекции?
Коллекции могут хранить любые ссылочные типы данных.

4. Какие есть типы коллекций? Как они характеризуются?
Set - множество неповторяющихся элементов (Здесь могут храниться только уникальные значения, нет дубликатов)
Queue (Deque) - очередь (FIFO первый вошел, первый вышел). реализует LinkedList
List - упорядоченный список (В какой последовательности данные положили, в такой они и хранятся. Допускаются дубликаты.)
Map - карта, ассоциативный массив (Значения хранятся в виде пар ключ=значение. Каждому элементу из множества ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. Map не наследуется от Collection.)

5. Назовите основные реализации List, Set, Map.
List: ArrayList, LinkedList
Set: HashSet, LinkedHashSat, TreeSet
Map: HashMap, LinkedHashMap, TreeMap

6. В чём отличие ArrayList от LinkedList?
ArrayList - основан на динамическом массиве, хранит свои элементы в массиве. (используют, если элементы чаще читаются, чем добавляются)

+ Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

+ меньше расходует памяти на хранение элементов;

- увеличение ArrayList происходит медленно;

- при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

LinkedList - двунаправленный список (цепочка), хранит элементы в объектах Node<E>, у которых есть ссылки на предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются)

+ быстрая вставка и удаление в середину списка (переписать next и previous и всё);

- долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго. В среднем, сложности одинаковые, но все же ArrayList предпочтительнее использовать. LinkedList рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

7. В чём отличие HashSet от TreeSet?

Set - множество неповторяющихся элементов.
HashSet хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
TreeSet хранит данные в отсортированном виде (в основе реализации бинарное красно-черное дерево).

8. В чём отличие Set от Map?
сет это список ключей от мапы.

9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
Порядок задается либо естественным следованием элементов (natural order), либо объектом, реализующим интерфейс сравнения Comparator.
Можно отсортировать с помощью интерфейса Comparable или интерфейса Comparator:
Если объекты коллекции поддерживают интерфейс Comparable, то через Collections.sort(collection);
Если нет, то у коллекции вызвать метод sort() и передать ему Comparator в качестве аргумента collection.sort(new MyComparator()). Либо использовать метод Collections.sort(collection, new MyComparator()).

10. Чем отличается Comparable от Comparator?
Comparable - используется только для сравнения объектов класса, в котором данный интерфейс реализован. Т.е. интерфейс Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации (по правилам разработчика). Collections.sort(collection);
Comparator - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. Т.е. интерфейс Comparator позволяет создавать объекты, которые будут управлять процессом сравнения:
при сортировках в методах Collections.sort(collection, new MyComparator()), Arrays.sort(array, new MyComparator()) или collection.sort(new MyComparator())
при управлении порядком в отсортированных множествах TreeSet или отсортированных картах TreeMap, например new TreeSet<T> (new MyComparator()).
Разница:
Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если нет доступа к исходникам, ее невозможно изменить.
Comparator позволает определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту логику можно в любой момент подменить.
Comparable используется для natural ordering, а Comparator для total ordering.

11. Что такое сортировка по принципу Natural Order?
Некоторые классы из коробки реализуют естественный порядок natural order для сортировки:

строки - лексикографический (по алфавиту),
числа - числовой, знаковый или без (больше меньше),
дата - хронологичский (по датам),
файл - лексикографический по имени пути
boolean - false < true
Остальные классы нужно руками делать Comparable или Comparator.

12. Что такое equals и hashcode?
Методы, необходимые для определения равенства объектов.
hashcode возвращает число, являющееся уникальным идентификатором объекта. Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
equals сравнивает объекты по значению их полей.
Объекты всех коллекций в названии которых есть Hash... должны иметь hashcode и equals.

13. Какие есть способы перебора всех элементов List?
Есть список стран, его нужно перебрать

List<String> countries = Arrays.asList("Russia", "Panama", "Australia");
циклы for, while, foreach
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
for (String country : countries) {
    System.out.println(country);
}
итераторы Iterator, ListIterator
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}
Если вызвать метод next() итератора, указывающего на последний элемент в коллекции, то возникнет исключение NoSuchElementException. Следует это помнить и использовать метод hasNext() перед вызовом next().

функция forEach()

Iterable.forEach() можно использовать для итерации по элементам списка начиная с Java 8. Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
countries.forEach(System.out::println);
Stream.forEach() Мы также можем преобразовать коллекцию значений в поток и получить доступ к таким операциям, как forEach(), map(), или filter().
countries.stream().forEach(
    (c) -> System.out.println(c)
);

14. Как реализован цикл foreach?
  Для коллекции и массивов предпочтительней использовать цикл for-earch.
  for (Object value : names) {
      System.out.println(value);
  }
  Эта конструкция предотвращает появление ошибок,
  связанных с обращением к несуществующей ячейке - IndexOutOfBoundsException.
  foreach реализован на основе Iterator, т.е. он работает для классов, реализующих интерфейс Iterable.
  (И наоборот, если коллекция extends от Iterable, то мы можем перебирать элементы этой коллекции с помощью foreach)

15. В чем разница между Iterator и Iterable?
ListIterator расширяет Iterator, отличия следующие:
Iterator может использоваться для перебора элементов коллекций Set, List и Map. ListIterator может быть использован только для перебора элементов коллекции List
Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous().
ListIterator позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов add(), set() remove(). Iterator не поддерживает данного функционала.

16. Как происходит удаление элементов из ArrayList?
Находится заданный элемент. Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение size уменьшается на 1.

Непосредственно под капотом:

System.arraycopy(es, i + 1, es, i, newSize - i)
es[size = newSize] = null;

17. Как происходит удаление элементов из LinkedList?
Заменяются ссылки previous и next у соседних элементов.

